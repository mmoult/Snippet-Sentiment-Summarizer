package classifying;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;
import java.util.Stack;

import parsing.DataCleaner;
import util.OpinRankFiles;

public class Classifier {
	/**
	 * An internally used array that gives the name of the categories we are
	 * sorting into (generally the name of the path where the documents were found),
	 * and all the file paths that should be read to collect documents.
	 */
	private Category[] categories;
	/**
	 * Classes is a list that holds all the words used by the documents in each
	 * category (class). The size of "classes" == the size of "categories".
	 * The 0th Category in categories corresponds to the 0th CountedWords in
	 * "classes", and so on.
	 */
	private List<CountedWords> classes;
	/**
	 * Entries is a list (by category) of documents (entries) used. The 0th index
	 * in "entries" has a list of all documents sorted into the 0th category during
	 * training. The 1st index in "entries" has a list of documents sorted into the
	 * 1st category during training, and so forth.
	 */
	private List<List<CountedWords>> entries;
	/**
	 * P(c) is the chance that any document is in the class c. Typically, we estimate
	 * this by using our proportion of training data for each category. However, since
	 * this requires stringently policing of what is used for training, we currently
	 * set pC to 1 / num of categories for each index. (Yet, we leave the other estimate
	 * in the code in case of future use.)
	 * <p>
	 * pC[0] is the proportion of training documents in the first category, pC[1]
	 * is the proportion of training documents in the second, etc.
	 * <p>
	 * pC is initialized and properly set in {@link #init(boolean)}.
	 */
	private double[] pC;
	
	//Some debugging and printing variables. Constant during runtime, but can be
	//changed before compilation for customized output.
	private final int TRAINING_NUMBER = 100;
	private final int TEST_NUMBER = 100;
	private final boolean PRINT_EACH_TEST = true;
	private final boolean PRINT_LOADED_FILES = false;
	
	
	/**
	 * Loads the classifier (for hotels and cars), performs some tests and stays
	 * open to accept user queries.
	 */
	public static void main(String args[]) throws IOException {
		char sep = File.separatorChar;
		String searchPath = OpinRankFiles.root + sep;
		// For the sake of time, we will blacklist some folders.
		List<String> blackList = Arrays.asList("2007", "2009", "beijing", "dubai", "london", "montreal", "new-delhi", "shanghai");
		Classifier classifier = new Classifier(true, searchPath, blackList);
		System.out.println("Classifier loaded!");
		
		//OPTIONAL user query sort
		Scanner scan = new Scanner(System.in);
		while(scan.hasNextLine()) {
			String line = scan.nextLine();
			if(line.isEmpty())
				break; //quit signal
			
			DataCleaner cleaner = new DataCleaner();
			List<String> tokens = cleaner.filterStopWords(DataCleaner.removePunctuation(line, false), true);
			String classChosen = classifier.classify(tokens);
			System.out.println("Sorted into " + classChosen);
		}
		scan.close();
	}
	
	/**
	 * Loads the classifier and recursively searches all files and subdirectories at the
	 * specified path. The top directories at the specified path are the categories, and
	 * any files found in those directories are also counted with. Optionally performs tests.
	 * <p> To be considered, a file must have a .txt file extension! These files can be
	 * generated by using {@link parsing.ReviewCleaner}.
	 * @param performTests whether to perform tests
	 * @param searchDirectory the directory to search for classification documents
	 * @throws IOException if there is some error with looking for files at the path
	 */
	public Classifier(boolean performTests, String searchDirectory, List<String> blackList) throws IOException {
		//We want to establish the categories at the given directory
		File[] subdirs = new File(searchDirectory).listFiles();
		List<File> catNames = new ArrayList<>();
		for(File dir: subdirs) {
			if(dir.isDirectory() && !blackList.contains(dir.getName()))
				catNames.add(dir);
			else if(dir.isFile() && dir.getName().endsWith(".txt") && !blackList.contains(dir.getName()))
				catNames.add(dir);
		}
		this.categories = new Category[catNames.size()];
		for(int i=0; i<catNames.size(); i++) {
			File catName = catNames.get(i);
			//recursively get all file names
			List<String> subFiles = new ArrayList<>();
			Stack<File> toAnalyze = new Stack<>();
			toAnalyze.push(catName);
			while(!toAnalyze.isEmpty()) {
				File analyze = toAnalyze.pop();
				if(blackList.contains(analyze.getName()))
					continue; //skip names matching the blacklist
				
				if(analyze.isFile() && analyze.getName().endsWith(".txt"))
					subFiles.add(analyze.getCanonicalPath());
				else if(analyze.isDirectory()) {
					File[] subs = analyze.listFiles();
					for(File sub: subs)
						toAnalyze.push(sub);
				}
			}
			categories[i] = new Category(catName.getCanonicalPath(), subFiles);
		}
		
		init(performTests);
	}
	
	/**
	 * Loads the data from all of the files in the metaFiles array. Called by both
	 * constructors.
	 * @param performTests whether or not to perform tests on remaining file entries
	 * @throws FileNotFoundException if the files are not found
	 */
	protected void init(boolean performTests) throws FileNotFoundException {
		pC = new double[categories.length];
		classes = new ArrayList<>(categories.length);
		entries = new ArrayList<>(categories.length);
		
		for(int i=0; i<categories.length; i++) {
			classes.add(new CountedWords());
			entries.add(new ArrayList<>());
		}
		
		//for classification of metadata, the asin field does not matter. We just need the words
		//We need to have some number of training data entries, from which we can sort the rest of
		//the entries and test accuracy
		int totalNumFiles = 0;
		for(int i=0; i<categories.length; i++)
			totalNumFiles += categories[i].directories.size();
		
		Scanner[] scanners = new Scanner[totalNumFiles];
		int iii = 0;
		for(int k=0; k<categories.length; k++) {
			for(int i=0; i<categories[k].directories.size(); i++) {
				if(PRINT_LOADED_FILES)
					System.out.println("Loading file \"" + categories[k].directories.get(i) + "\"...");
				scanners[iii] = new Scanner(new File(categories[k].directories.get(i)));
				train(scanners[iii], k);
				iii++;
			}
		}
		
		//After the sets are all built, we want to maximize P(c | d):
		//	P(c | d) = [P(d | c) P(c)] / [SUM_[c in C] P(d | c) P(c)]
		//Also, P(d | c), which is proportional to  PRODUCT_[w in V] P(w|c)^(tf_w,d)
		//which then requires P(w|c) = [tfw,c + 1] / [|c| + |V|]
		
		if(PRINT_LOADED_FILES)
			System.out.println("Calculating...");
		@SuppressWarnings("unused")
		int trainingSum = 0;
		for(int j=0; j<categories.length; j++) {
			trainingSum += entries.get(j).size();
		}
		// P(c) = N_c/N
		for(int j=0; j<categories.length; j++) {
			//pC[j] = entries.get(j).size() / (double)trainingSum;
			pC[j] = 1 / (double)categories.length;
		}
		
		if(performTests) {
			System.out.println("Performing Tests...");
			
			int scanNo = 0;
			ArrayList<List<Integer>> openFiles = new ArrayList<>(categories.length);
			for(int ii=0; ii<categories.length; ii++) {
				ArrayList<Integer> filesOpen = new ArrayList<>();
				for(iii=0; iii<categories[ii].directories.size(); iii++) {
					if(scanners[scanNo].hasNextLine())
						filesOpen.add(scanNo);
					scanNo++;
				}
				openFiles.add(filesOpen);
			}
			if(openFiles.isEmpty()) {
				System.out.println("No more files to conduct testing!");
				return;
			}
				
			//run tests to see how the classifier is working
			int numCorrect = 0;
			int i=0; //serves as the number of tests performed if early break
			for(; i<TEST_NUMBER; i++) {
				if(i % (TEST_NUMBER/10) == 0)
					System.out.println("--------- "+((100d * i) / TEST_NUMBER) + "%");
				
				//No more available categories
				if(openFiles.isEmpty()) {
					System.out.println("Ran out of available files!");
					break;
				}
				int index = (int)(Math.random()*openFiles.size()); //randomly select the category
				//If a category has been all used up, remove it
				if(openFiles.get(index).isEmpty()) {
					openFiles.remove(index);
					i--;
					continue;
				}
				int inIndex = (int)(Math.random()*openFiles.get(index).size()); //randomly select file within
				
				int rand = openFiles.get(index).get(inIndex);
				
				if(scanners[rand].hasNextLine()) {
					String line = scanners[rand].nextLine();
					int wordsStart = line.indexOf("\"words\": ");
					if(wordsStart == -1) {//occurs for empty lines or intro lines
						i--; //don't count this line as a test
						continue;
					}
					
					String words = line.substring(wordsStart + 9);
					String[] allWords = words.split(" ");
					CountedWords entry = new CountedWords();
					for(String word: allWords) {
						//we want to ignore any sentence breaks we come across
						if(word.equals("|"))
							continue;
						
						//add this word to the correct entry
						entry.addWord(word);
					}
					
					//now we want to run the test and see which class it fits best in
					int classChosen = classify(entry);
					if(PRINT_EACH_TEST)
						System.out.println("guess:actual " + classChosen + " " + index);
					else if(classChosen != index)
						System.out.println("guess:actual " + classChosen + " " + index);
					//the class chosen is at index classChosen
					//if classChosen matches rand, then the classification was correct
					if(classChosen == index)
						numCorrect++;
				}else {
					i--;
					//if a file has been all used, remove it
					openFiles.get(index).remove(inIndex);
					continue;
				}
			}
			
			System.out.println("Tests finished! " + numCorrect + "/" + i);
		}
		
		for(int i=0; i<scanners.length; i++) {
			if(scanners[i] != null)
				scanners[i].close();
		}
	}
	
	private void train(Scanner scan, int category) {
		for(int j=0; j<TRAINING_NUMBER; j++) {
			if(scan.hasNextLine()) {
				String line = scan.nextLine();
				int wordsStart = line.indexOf("\"words\": ");
				if(wordsStart == -1) {//occurs for empty lines or intro lines
					j--; //don't count this line as an entry added
					continue;
				}
				
				String words = line.substring(wordsStart + 9);
				//words = words.substring(0, words.length()-1); //remove the final quote
				String[] allWords = words.split(" ");
				CountedWords entry = new CountedWords();
				for(String word: allWords) {
					//add this word to the correct class and entry
					entry.addWord(word);
					classes.get(category).addWord(word);
				}
				entries.get(category).add(entry);
			}else {
				break;
			}
		}
	}
	
	public String classify(List<String> toClassify) {
		CountedWords doc = new CountedWords();
		for(String term: toClassify) {
			doc.addWord(term);
		}
		
		int res = classify(doc);
		return categories[res].name;
	}
	private int classify(CountedWords document) {
		double pCofDMax = 0;
		int classChosen = -1;
		for(int j=0; j<categories.length; j++) {
			// P(c | d) = [P(d | c) P(c)] / [SUM_[c in C] P(d | c) P(c)]
			//  As I understand it, since all arguments are divided by the same denominator
			//  used to make it a probability (out of 1), then we can simply ignore the
			//  denominator completely here and simply select the highest numerator
			
			// P(d | c) = PRODUCT_[w in V] P(w|c)^(tf_w,d)
			double pDofC = 1;
			// P(w|c) = [tfw,c + 1] / [|c| + |V|]
			CountedWords clazz = classes.get(j);
			for(String word: document.getDistinct()) {
				//Laplacian smoothed here
				double base = (clazz.getOccurrences(word) + 1d) /
						//(clazz.getSize() + clazz.getDistinctSize()); //TRUE
						(clazz.getDistinctSize()); //MORE ACCURATE AND FASTER
				//double pWofC = Math.pow(base, entry.getOccurences(word)); //TRUE
				//normalization on exponent?
				double pWofC = Math.pow(base, document.getOccurrences(word)/(double)document.getSize());
				pDofC *= pWofC;
			}
			double pCofD = pDofC * pC[j];
			if(classChosen == -1 || pCofD > pCofDMax) {
				classChosen = j;
				pCofDMax = pCofD;
			}
		}
		return classChosen;
	}
	
	private class Category {
		public String name;
		public List<String> directories;
		
		public Category(String categoryName, List<String> directories) {
			this.name = categoryName;
			this.directories = directories;
		}
	}

}
